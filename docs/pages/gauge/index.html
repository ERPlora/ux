<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
    background: var(--ux-surface-secondary);
  }
  .demo-section {
    margin-bottom: 3rem;
  }
  .demo-section h2 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: var(--ux-text);
  }
  .demo-box {
    background: var(--ux-surface);
    border-radius: 16px;
    padding: 1.5rem;
    margin-bottom: 1rem;
  }
  .demo-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 1.5rem;
  }
  .demo-flex {
    display: flex;
    flex-wrap: wrap;
    gap: 2rem;
    align-items: center;
    justify-content: center;
  }
  .result-display {
    margin-top: 1rem;
    padding: 0.75rem;
    background: var(--ux-surface-secondary);
    border-radius: 8px;
    font-size: 0.875rem;
    text-align: center;
  }
  .demo-glass-bg {
    background: linear-gradient(135deg, var(--ux-cyan-500), var(--ux-blue-600));
    padding: 1.5rem;
    border-radius: 16px;
    display: flex;
    justify-content: center;
    gap: 2rem;
    flex-wrap: wrap;
  }
</style>

<h1 style="margin-bottom: 0.5rem;">Gauge / Meter</h1>
<p style="color: var(--ux-text-secondary); margin-bottom: 2rem;">
  Indicador visual tipo gauge/velocimetro con arco, aguja opcional y segmentos de colores.
</p>

<!-- Basic Gauge -->
<section class="component-section">
  <h2>Gauge Basico</h2>

  <ux-playground src="pages/gauge/examples/basico.html"></ux-playground>

  <ux-code src="pages/gauge/examples/basico.html" lang="html"></ux-code>
</section>

<!-- Sizes -->
<section class="component-section">
  <h2>Tamanos</h2>

  <ux-playground src="pages/gauge/examples/tamanos.html"></ux-playground>
</section>

<!-- Color States -->
<section class="component-section">
  <h2>Estados de Color</h2>

  <ux-playground src="pages/gauge/examples/estados-color.html"></ux-playground>
</section>

<!-- Interactive -->
<section class="component-section">
  <h2>Gauge Interactivo</h2>

  <ux-playground src="pages/gauge/examples/interactivo.html"></ux-playground>
</section>

<!-- With Needle -->
<section class="component-section">
  <h2>Con Aguja (Speedometer Style)</h2>

  <ux-playground src="pages/gauge/examples/con-aguja.html"></ux-playground>
</section>

<!-- Custom Range -->
<section class="component-section">
  <h2>Rango Personalizado</h2>

  <ux-playground src="pages/gauge/examples/rango-personalizado.html"></ux-playground>
</section>

<!-- Glass Variant -->
<section class="component-section">
  <h2>Variante Glass</h2>

  <ux-playground src="pages/gauge/examples/glass.html"></ux-playground>
</section>

<!-- CSS Classes Reference -->
<section class="component-section">
  <h2>Referencia de Clases CSS</h2>

  <ux-playground src="pages/gauge/examples/referencia-clases.html"></ux-playground>
</section>

<!-- HTMX + Django -->
<section class="component-section">
  <h2>HTMX + Django</h2>

  <p style="color: var(--ux-text-secondary); margin-bottom: 1.5rem;">
    Ejemplos de gauge con actualizacion en tiempo real usando HTMX y Django.
    Los valores se actualizan automaticamente mediante polling o SSE (Server-Sent Events).
  </p>

  <ux-playground src="pages/gauge/examples/htmx-polling.html"></ux-playground>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Polling con HTMX</h3>
  <pre class="ux-code-block" data-lang="html">&lt;!-- El gauge se actualiza cada 2 segundos --&gt;
&lt;div hx-get="/api/metrics/cpu/"
     hx-trigger="every 2s"
     hx-swap="innerHTML"&gt;
  {% include "partials/gauge.html" with value=cpu_usage unit="%" label="CPU" %}
&lt;/div&gt;</pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Template Parcial Django (partials/gauge.html)</h3>
  <pre class="ux-code-block" data-lang="html">&lt;div x-data="uxGauge({ value: {{ value }}, unit: '{{ unit }}', label: '{{ label }}' })"
     class="ux-gauge ux-gauge--md {% if value &gt;= 80 %}ux-gauge--danger{% elif value &gt;= 50 %}ux-gauge--warning{% else %}ux-gauge--success{% endif %}"&gt;
  &lt;svg class="ux-gauge__svg" :width="size" :height="size * 0.6" :viewBox="`0 0 ${size} ${size * 0.65}`"&gt;
    &lt;path class="ux-gauge__track" :d="arcPath" :stroke-width="strokeWidth" /&gt;
    &lt;path class="ux-gauge__fill" :d="arcPath" :stroke-width="strokeWidth"
          :stroke-dasharray="circumference" :stroke-dashoffset="dashOffset" /&gt;
  &lt;/svg&gt;
  &lt;div class="ux-gauge__value-container" :style="valueContainerStyle"&gt;
    &lt;span class="ux-gauge__value" x-text="displayValue"&gt;&lt;/span&gt;
    &lt;span class="ux-gauge__unit" x-text="unit"&gt;&lt;/span&gt;
    &lt;span class="ux-gauge__label" x-text="label"&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Vista Django con API JSON</h3>
  <pre class="ux-code-block" data-lang="python"># views.py
from django.http import JsonResponse
from django.shortcuts import render
import psutil

def cpu_gauge_partial(request):
    """Retorna el HTML parcial del gauge con valor actual de CPU."""
    cpu_usage = psutil.cpu_percent(interval=0.1)
    return render(request, 'partials/gauge.html', {
        'value': cpu_usage,
        'unit': '%',
        'label': 'CPU Usage'
    })

def metrics_api(request):
    """API JSON para actualizar gauge via Alpine.js."""
    return JsonResponse({
        'cpu': psutil.cpu_percent(interval=0.1),
        'memory': psutil.virtual_memory().percent,
        'disk': psutil.disk_usage('/').percent,
        'temperature': get_cpu_temperature()  # Implementar segun hardware
    })</pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">SSE con HTMX Extension</h3>
  <pre class="ux-code-block" data-lang="html">&lt;!-- Requiere htmx-ext-sse --&gt;
&lt;script src="https://unpkg.com/htmx-ext-sse@2.0.0/sse.js"&gt;&lt;/script&gt;

&lt;!-- Gauge que se actualiza via SSE --&gt;
&lt;div hx-ext="sse"
     sse-connect="/sse/metrics/"
     sse-swap="temperature"&gt;
  {% include "partials/gauge.html" with value=initial_temp unit="°C" label="Temp" %}
&lt;/div&gt;</pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Vista Django SSE</h3>
  <pre class="ux-code-block" data-lang="python"># views.py
from django.http import StreamingHttpResponse
import time

def sse_metrics(request):
    """Stream de metricas via Server-Sent Events."""
    def event_stream():
        while True:
            temp = get_cpu_temperature()
            # Renderizar gauge HTML
            html = render_to_string('partials/gauge.html', {
                'value': temp,
                'unit': '°C',
                'label': 'Temperature'
            })
            # Enviar evento SSE
            yield f"event: temperature\ndata: {html}\n\n"
            time.sleep(1)

    response = StreamingHttpResponse(
        event_stream(),
        content_type='text/event-stream'
    )
    response['Cache-Control'] = 'no-cache'
    response['X-Accel-Buffering'] = 'no'
    return response</pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Actualizar solo el valor via Alpine.js + Fetch</h3>
  <pre class="ux-code-block" data-lang="html">&lt;!-- Gauge que actualiza solo el valor sin recargar el HTML --&gt;
&lt;div x-data="{
       ...uxGauge({ value: {{ initial_value }}, unit: '%', label: 'CPU' }),

       // Polling manual
       startPolling() {
         setInterval(async () =&gt; {
           const res = await fetch('/api/metrics/');
           const data = await res.json();
           this.setValue(data.cpu);
         }, 2000);
       }
     }"
     x-init="startPolling()"
     class="ux-gauge ux-gauge--md"
     :class="{
       'ux-gauge--success': percentage &lt; 50,
       'ux-gauge--warning': percentage &gt;= 50 &amp;&amp; percentage &lt; 80,
       'ux-gauge--danger': percentage &gt;= 80
     }"&gt;
  &lt;!-- SVG del gauge --&gt;
&lt;/div&gt;</pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Dashboard con Multiples Gauges</h3>
  <pre class="ux-code-block" data-lang="html">&lt;!-- Dashboard que actualiza todos los gauges con una sola peticion --&gt;
&lt;div x-data="{
       metrics: { cpu: 0, memory: 0, disk: 0 },
       async fetchMetrics() {
         const res = await fetch('/api/metrics/');
         this.metrics = await res.json();
       },
       init() {
         this.fetchMetrics();
         setInterval(() =&gt; this.fetchMetrics(), 3000);
       }
     }"&gt;

  &lt;div class="row g-4"&gt;
    &lt;!-- CPU Gauge --&gt;
    &lt;div class="col-md-4"&gt;
      &lt;div x-data="uxGauge({ unit: '%', label: 'CPU' })"
           x-effect="setValue(metrics.cpu)"
           class="ux-gauge ux-gauge--md"
           :class="percentage &gt;= 80 ? 'ux-gauge--danger' : 'ux-gauge--success'"&gt;
        &lt;!-- SVG --&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Memory Gauge --&gt;
    &lt;div class="col-md-4"&gt;
      &lt;div x-data="uxGauge({ unit: '%', label: 'Memory' })"
           x-effect="setValue(metrics.memory)"
           class="ux-gauge ux-gauge--md"&gt;
        &lt;!-- SVG --&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- Disk Gauge --&gt;
    &lt;div class="col-md-4"&gt;
      &lt;div x-data="uxGauge({ unit: '%', label: 'Disk' })"
           x-effect="setValue(metrics.disk)"
           class="ux-gauge ux-gauge--md"&gt;
        &lt;!-- SVG --&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
</section>

<!-- Alpine.js Options -->
<section class="component-section">
  <h2>Opciones Alpine.js</h2>

  <div class="demo-box">
    <pre class="ux-code-block" data-lang="javascript">uxGauge({
  value: 0,               // Valor actual
  min: 0,                 // Valor minimo
  max: 100,               // Valor maximo
  size: 180,              // Tamano en pixeles
  strokeWidth: 12,        // Grosor del arco
  startAngle: -135,       // Angulo inicial (grados)
  endAngle: 135,          // Angulo final (grados)
  unit: '',               // Unidad (%, °C, km/h, etc.)
  label: '',              // Etiqueta descriptiva
  showValue: true,        // Mostrar valor numerico
  showLabels: true,       // Mostrar min/max
  showNeedle: false,      // Mostrar aguja tipo velocimetro
  showTicks: false,       // Mostrar marcas de escala
  tickCount: 10,          // Numero de marcas
  animated: true,         // Animacion al cambiar valor
  decimals: 0             // Decimales a mostrar
})

// Metodos
setValue(value)           // Establecer valor
increment(amount)         // Incrementar
decrement(amount)         // Decrementar

// Propiedades computadas
percentage                // Porcentaje (0-100)
normalizedValue           // Valor dentro de min/max
displayValue              // Valor formateado

// Eventos
@gauge:change             // Se dispara al cambiar el valor
                          // detail: { value, percentage }</pre>
  </div>
</section>
