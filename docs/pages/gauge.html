<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
    background: var(--ux-surface-secondary);
  }
  .demo-section {
    margin-bottom: 3rem;
  }
  .demo-section h2 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 1rem;
    color: var(--ux-text);
  }
  .demo-box {
    background: var(--ux-surface);
    border-radius: 16px;
    padding: 1.5rem;
    margin-bottom: 1rem;
  }
  .demo-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 1.5rem;
  }
  .demo-flex {
    display: flex;
    flex-wrap: wrap;
    gap: 2rem;
    align-items: center;
    justify-content: center;
  }
  .result-display {
    margin-top: 1rem;
    padding: 0.75rem;
    background: var(--ux-surface-secondary);
    border-radius: 8px;
    font-size: 0.875rem;
    text-align: center;
  }
  .demo-glass-bg {
    background: linear-gradient(135deg, var(--ux-cyan-500), var(--ux-blue-600));
    padding: 1.5rem;
    border-radius: 16px;
    display: flex;
    justify-content: center;
    gap: 2rem;
    flex-wrap: wrap;
  }
</style>

<h1 style="margin-bottom: 0.5rem;">Gauge / Meter</h1>
<p style="color: var(--ux-text-secondary); margin-bottom: 2rem;">
  Indicador visual tipo gauge/velocimetro con arco, aguja opcional y segmentos de colores.
</p>

<!-- Basic Gauge -->
<section class="component-section">
  <h2>Gauge Basico</h2>

  <ux-playground src="examples/gauge/basico.html"></ux-playground>

  <ux-code src="examples/gauge/basico.html" lang="html"></ux-code>
</section>

<!-- Sizes -->
<section class="component-section">
  <h2>Tamanos</h2>

  <ux-playground src="examples/gauge/tamanos.html"></ux-playground>
</section>

<!-- Color States -->
<section class="component-section">
  <h2>Estados de Color</h2>

  <ux-playground src="examples/gauge/estados-color.html"></ux-playground>
</section>

<!-- Interactive -->
<section class="component-section">
  <h2>Gauge Interactivo</h2>

  <ux-playground src="examples/gauge/interactivo.html"></ux-playground>
</section>

<!-- With Needle -->
<section class="component-section">
  <h2>Con Aguja (Speedometer Style)</h2>

  <ux-playground src="examples/gauge/con-aguja.html"></ux-playground>
</section>

<!-- Custom Range -->
<section class="component-section">
  <h2>Rango Personalizado</h2>

  <ux-playground src="examples/gauge/rango-personalizado.html"></ux-playground>
</section>

<!-- Glass Variant -->
<section class="component-section">
  <h2>Variante Glass</h2>

  <ux-playground src="examples/gauge/glass.html"></ux-playground>
</section>

<!-- CSS Classes Reference -->
<section class="component-section">
  <h2>Referencia de Clases CSS</h2>

  <ux-playground src="examples/gauge/referencia-clases.html"></ux-playground>
</section>

<!-- HTMX + Django -->
<section class="component-section">
  <h2>HTMX + Django</h2>

  <p style="color: var(--ux-text-secondary); margin-bottom: 1.5rem;">
    Ejemplos de gauge con actualizacion en tiempo real usando HTMX y Django.
    Los valores se actualizan automaticamente mediante polling o SSE (Server-Sent Events).
  </p>

  <ux-playground src="examples/gauge/htmx-polling.html"></ux-playground>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Polling con HTMX</h3>
  <pre class="ux-code-block" data-lang="html"><!-- El gauge se actualiza cada 2 segundos -->
<div hx-get="/api/metrics/cpu/"
     hx-trigger="every 2s"
     hx-swap="innerHTML">
  {% include "partials/gauge.html" with value=cpu_usage unit="%" label="CPU" %}
</div></pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Template Parcial Django (partials/gauge.html)</h3>
  <pre class="ux-code-block" data-lang="html"><div x-data="uxGauge({ value: {{ value }}, unit: '{{ unit }}', label: '{{ label }}' })"
     class="ux-gauge ux-gauge--md {% if value >= 80 %}ux-gauge--danger{% elif value >= 50 %}ux-gauge--warning{% else %}ux-gauge--success{% endif %}">
  <svg class="ux-gauge__svg" :width="size" :height="size * 0.6" :viewBox="`0 0 ${size} ${size * 0.65}`">
    <path class="ux-gauge__track" :d="arcPath" :stroke-width="strokeWidth" />
    <path class="ux-gauge__fill" :d="arcPath" :stroke-width="strokeWidth"
          :stroke-dasharray="circumference" :stroke-dashoffset="dashOffset" />
  </svg>
  <div class="ux-gauge__value-container" :style="valueContainerStyle">
    <span class="ux-gauge__value" x-text="displayValue"></span>
    <span class="ux-gauge__unit" x-text="unit"></span>
    <span class="ux-gauge__label" x-text="label"></span>
  </div>
</div></pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Vista Django con API JSON</h3>
  <pre class="ux-code-block" data-lang="python"># views.py
from django.http import JsonResponse
from django.shortcuts import render
import psutil

def cpu_gauge_partial(request):
    """Retorna el HTML parcial del gauge con valor actual de CPU."""
    cpu_usage = psutil.cpu_percent(interval=0.1)
    return render(request, 'partials/gauge.html', {
        'value': cpu_usage,
        'unit': '%',
        'label': 'CPU Usage'
    })

def metrics_api(request):
    """API JSON para actualizar gauge via Alpine.js."""
    return JsonResponse({
        'cpu': psutil.cpu_percent(interval=0.1),
        'memory': psutil.virtual_memory().percent,
        'disk': psutil.disk_usage('/').percent,
        'temperature': get_cpu_temperature()  # Implementar segun hardware
    })</pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">SSE con HTMX Extension</h3>
  <pre class="ux-code-block" data-lang="html"><!-- Requiere htmx-ext-sse -->
<script src="https://unpkg.com/htmx-ext-sse@2.0.0/sse.js"></script>

<!-- Gauge que se actualiza via SSE -->
<div hx-ext="sse"
     sse-connect="/sse/metrics/"
     sse-swap="temperature">
  {% include "partials/gauge.html" with value=initial_temp unit="°C" label="Temp" %}
</div></pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Vista Django SSE</h3>
  <pre class="ux-code-block" data-lang="python"># views.py
from django.http import StreamingHttpResponse
import time

def sse_metrics(request):
    """Stream de metricas via Server-Sent Events."""
    def event_stream():
        while True:
            temp = get_cpu_temperature()
            # Renderizar gauge HTML
            html = render_to_string('partials/gauge.html', {
                'value': temp,
                'unit': '°C',
                'label': 'Temperature'
            })
            # Enviar evento SSE
            yield f"event: temperature\ndata: {html}\n\n"
            time.sleep(1)

    response = StreamingHttpResponse(
        event_stream(),
        content_type='text/event-stream'
    )
    response['Cache-Control'] = 'no-cache'
    response['X-Accel-Buffering'] = 'no'
    return response</pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Actualizar solo el valor via Alpine.js + Fetch</h3>
  <pre class="ux-code-block" data-lang="html"><!-- Gauge que actualiza solo el valor sin recargar el HTML -->
<div x-data="{
       ...uxGauge({ value: {{ initial_value }}, unit: '%', label: 'CPU' }),

       // Polling manual
       startPolling() {
         setInterval(async () => {
           const res = await fetch('/api/metrics/');
           const data = await res.json();
           this.setValue(data.cpu);
         }, 2000);
       }
     }"
     x-init="startPolling()"
     class="ux-gauge ux-gauge--md"
     :class="{
       'ux-gauge--success': percentage < 50,
       'ux-gauge--warning': percentage >= 50 && percentage < 80,
       'ux-gauge--danger': percentage >= 80
     }">
  <!-- SVG del gauge -->
</div></pre>

  <h3 style="margin: 2rem 0 1rem; font-size: 1rem;">Dashboard con Multiples Gauges</h3>
  <pre class="ux-code-block" data-lang="html"><!-- Dashboard que actualiza todos los gauges con una sola peticion -->
<div x-data="{
       metrics: { cpu: 0, memory: 0, disk: 0 },
       async fetchMetrics() {
         const res = await fetch('/api/metrics/');
         this.metrics = await res.json();
       },
       init() {
         this.fetchMetrics();
         setInterval(() => this.fetchMetrics(), 3000);
       }
     }">

  <div class="row g-4">
    <!-- CPU Gauge -->
    <div class="col-md-4">
      <div x-data="uxGauge({ unit: '%', label: 'CPU' })"
           x-effect="setValue(metrics.cpu)"
           class="ux-gauge ux-gauge--md"
           :class="percentage >= 80 ? 'ux-gauge--danger' : 'ux-gauge--success'">
        <!-- SVG -->
      </div>
    </div>

    <!-- Memory Gauge -->
    <div class="col-md-4">
      <div x-data="uxGauge({ unit: '%', label: 'Memory' })"
           x-effect="setValue(metrics.memory)"
           class="ux-gauge ux-gauge--md">
        <!-- SVG -->
      </div>
    </div>

    <!-- Disk Gauge -->
    <div class="col-md-4">
      <div x-data="uxGauge({ unit: '%', label: 'Disk' })"
           x-effect="setValue(metrics.disk)"
           class="ux-gauge ux-gauge--md">
        <!-- SVG -->
      </div>
    </div>
  </div>
</div></pre>
</section>

<!-- Alpine.js Options -->
<section class="component-section">
  <h2>Opciones Alpine.js</h2>

  <div class="demo-box">
    <pre class="ux-code-block" data-lang="javascript">uxGauge({
  value: 0,               // Valor actual
  min: 0,                 // Valor minimo
  max: 100,               // Valor maximo
  size: 180,              // Tamano en pixeles
  strokeWidth: 12,        // Grosor del arco
  startAngle: -135,       // Angulo inicial (grados)
  endAngle: 135,          // Angulo final (grados)
  unit: '',               // Unidad (%, °C, km/h, etc.)
  label: '',              // Etiqueta descriptiva
  showValue: true,        // Mostrar valor numerico
  showLabels: true,       // Mostrar min/max
  showNeedle: false,      // Mostrar aguja tipo velocimetro
  showTicks: false,       // Mostrar marcas de escala
  tickCount: 10,          // Numero de marcas
  animated: true,         // Animacion al cambiar valor
  decimals: 0             // Decimales a mostrar
})

// Metodos
setValue(value)           // Establecer valor
increment(amount)         // Incrementar
decrement(amount)         // Decrementar

// Propiedades computadas
percentage                // Porcentaje (0-100)
normalizedValue           // Valor dentro de min/max
displayValue              // Valor formateado

// Eventos
@gauge:change             // Se dispara al cambiar el valor
                          // detail: { value, percentage }</pre>
  </div>
</section>
